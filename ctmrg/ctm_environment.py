import numpy as np

from symmetric_tensor.symmetric_tensor import AsymmetricTensor, U1_SymmetricTensor


def _initialize_env(A):
    #
    #   C1-0  3-T1-0  1-C2            0
    #   |       ||       |             \ 2
    #   1       12       0              \|
    #                                  5-A-3
    #   0       0        0               |\
    #   |       |        |               4 1
    #   T4=1  3-a--1  2=T2
    #   |  2    |     3  |
    #   3       2        1
    #
    #   0       01       0
    #   |       ||       |
    #   C4-1  3-T3-2  1-C3
    #
    a = (
        np.tensordot(A, A.conj(), ((0, 1), (0, 1)))
        .transpose(0, 4, 1, 5, 2, 6, 3, 7)
        .copy()
    )
    C1 = np.einsum("aacdefgg->cdef", a).reshape(A.shape[3] ** 2, A.shape[4] ** 2)
    T1 = np.einsum("aacdefgh->cdefgh", a).reshape(
        A.shape[3] ** 2, A.shape[4], A.shape[4], A.shape[5] ** 2
    )
    C2 = np.einsum("aaccefgh->efgh", a).reshape(A.shape[4] ** 2, A.shape[5] ** 2)
    T2 = np.einsum("abccefgh->abefgh", a).reshape(
        A.shape[2] ** 2, A.shape[4] ** 2, A.shape[5], A.shape[5]
    )
    C3 = np.einsum("abcceegh->abgh", a).reshape(A.shape[2] ** 2, A.shape[5] ** 2)
    T3 = np.einsum("abcdeegh->abcdgh", a).reshape(
        A.shape[2], A.shape[2], A.shape[3] ** 2, A.shape[5] ** 2
    )
    C4 = np.einsum("abcdeegg->abcd", a).reshape(A.shape[2] ** 2, A.shape[3] ** 2)
    T4 = np.einsum("abcdefgg->abcdef", a).reshape(
        A.shape[2] ** 2, A.shape[3], A.shape[3], A.shape[4] ** 2
    )
    return C1, T1, C2, T4, T2, C4, T3, C3


def _block_AAconj(A):
    """
    Construct U1_SymmetricTensor versions of double layer tensor a = A-A* that can be
    used in add_a_blockU1. a is a matrix with merged bra and ket legs *and* legs merged
    in two directions as rows and as columns. One version for each corner is needed, so
    we have a_ul, a_ur, a_dl and a_dr. However to save memory, a_dl and a_dr can be
    defined as a_ur.T and a_dl.T and use same memory storage.
    To be able to use a_ur and a_ul in the same function, unconventional leg order is
    required in a_ur. Here, we use 4-legs tensor to specify leg ordering, but as
    U1_SymmetricTensor matrices legs 0 and 1 are merged, so are legs 2 and 3.
       2                       3
       ||                      ||
    3=a_ul=0                1=a_ur=2
       ||                      ||
        1                       0

       1                       0
       ||                      ||
    3=a_dl=0 = a_ur.T       1=a_dr=2 = a_ul.T
       ||                      ||
        2                       3
    """
    a = A.H @ A
    # a_ul used to contract corner_ul: u and l legs are *last* for a_ul @ TT
    a_ul = a.permutate((1, 5, 2, 6), (0, 4, 3, 7))
    a_ur = a.permutate((2, 6, 3, 7), (1, 5, 0, 4))
    return a_ul, a_ur


class CTM_Environment(object):
    """
    Container for CTMRG environment tensors. Follow leg conventions from CTMRG.
    """

    def __init__(self, cell, neq_As, env_tensors=None):
        """
        Initialize environment tensors. Consider calling from_elementary_tensors
        or from_file instead of directly calling this function.

        cell: numpy array dype=U1
        neq_As: enum of SymmetricTensors
        env_tensors: dic, as generated by from_file
        """

        # 1 Define indices and neq_coords from cell
        # construct list of unique letters sorted according to appearance order in cell
        # (may be different from lexicographic order)
        seen = set()
        seen_add = seen.add
        letters = [c for c in cell.flat if not (c in seen or seen_add(c))]

        self._Nneq = len(letters)
        assert len(neq_As) == self._Nneq
        self._symmetry = neq_As[0].symmetry

        # [row,col] indices are transposed from (x,y) coordinates but (x,y) is natural
        # to specify positions, so we need to transpose indices here to get simple CTMRG
        # code. Construct indices and neq_coords such that
        # - for all i in range(Nneq), i == indices[neq_coords[i][0], neq_coords[i][1]]
        # - for all (x,y) in neq_coords, (x,y) == neq_coords[indices[x,y]]
        self._neq_coords = np.empty((self._Nneq, 2), dtype=np.int8)
        indices = np.empty(cell.shape, dtype=int)
        for i, l in enumerate(letters):
            inds_l = cell == l  # a tensor can appear more than once in tiling
            ind_values = inds_l.nonzero()
            self._neq_coords[i] = ind_values[1][0], ind_values[0][0]  # transpose
            indices[inds_l] = i

        self._Ly, self._Lx = cell.shape
        self._cell = cell
        self._indices = indices.T.copy()  # transpose

        # 2) store tensors. They have to follow cell.flat order.
        self._neq_As = tuple(neq_As)
        self._Dmax = max(max(A.shape[2:]) for A in self._neq_As)

        # 3) construct blockwise A-A*
        self._a_ur = []
        self._a_ul = []
        self._a_rd = []
        self._a_dl = []
        for A in neq_As:
            a_ul, a_ur = _block_AAconj(A)
            self._a_ur.append(a_ur)
            self._a_ul.append(a_ul)
            self._a_rd.append(a_ul.T)
            self._a_dl.append(a_ur.T)

        # 4) initialize corners and edges
        if env_tensors is None:
            self.restart()
        else:
            self._neq_C1s = env_tensors["neq_C1s"]
            self._neq_T1s = env_tensors["eq_T1s"]
            self._neq_C2s = env_tensors["eq_C2s"]
            self._neq_T2s = env_tensors["eq_T2s"]
            self._neq_C3s = env_tensors["eq_C3s"]
            self._neq_T3s = env_tensors["eq_T3s"]
            self._neq_C4s = env_tensors["eq_C4s"]
            self._neq_T4s = env_tensors["eq_T4s"]

            self._corners_ul = [None] * self._Nneq
            self._corners_ur = [None] * self._Nneq
            self._corners_dl = [None] * self._Nneq
            self._corners_dr = [None] * self._Nneq
            self._reset_temp_lists()

        # 5) check everything is fine
        assert self.has_consistent_shapes()

    @property
    def symmetry(self):
        return self._symmetry

    @property
    def Dmax(self):
        return self._Dmax

    @property
    def chi_max(self):
        chi_max = 0
        for C in self._neq_C1s + self._neq_C2s + self._neq_C3s + self._neq_C4s:
            chi_max = max(chi_max, *C.shape)
        return chi_max

    def has_consistent_shapes(self):
        if not (
            self._Nneq
            == len(self._neq_As)
            == len(self._neq_C1s)
            == len(self._neq_T1s)
            == len(self._neq_C2s)
            == len(self._neq_T2s)
            == len(self._neq_C3s)
            == len(self._neq_T3s)
            == len(self._neq_C4s)
            == len(self._neq_T4s)
        ):
            return False
        return True

    def restart(self):
        """
        Erase current environment tensors C and T and restart them from elementary
        tensors.
        """
        self._neq_C1s = []
        self._neq_T1s = []
        self._neq_C2s = []
        self._neq_T2s = []
        self._neq_C3s = []
        self._neq_T3s = []
        self._neq_C4s = []
        self._neq_T4s = []
        for i, A in enumerate(self._neq_As):
            C1, T1, C2, T4, T2, C4, T3, C3 = _initialize_env(A)
            self._neq_C1s[i].append(C1)
            self._neq_T1s[i].append(T1)
            self._neq_C2s[i].append(C2)
            self._neq_T2s[i].append(T2)
            self._neq_C3s[i].append(C3)
            self._neq_T3s[i].append(T3)
            self._neq_C4s[i].append(C4)
            self._neq_T4s[i].append(T4)

        self._corners_ul = [None] * self._Nneq
        self._corners_ur = [None] * self._Nneq
        self._corners_dl = [None] * self._Nneq
        self._corners_dr = [None] * self._Nneq
        self._reset_temp_lists()

    @classmethod
    def from_elementary_tensors(cls, tensors, tiling, axes_list=None):
        """
        Construct CTM_Environment from elementary tensors according to tiling.

        Parameters
        ----------
        tensors : iterable of Nneq numpy arrays
            Tensors given from left to right and up to down (as in array.flat)
        tiling : string
            Tiling pattern, such as 'AB\nCD'.
        axes_list : optional, list of Nneq axis_reps
            U(1) quantum numbers corresponding to the tensors. Note that dimensions are
            checked for compatibility with tensors, but irreps compatibility between
            legs to contract is not checked.
        """
        txt = [" ".join(w) for w in tiling.strip().splitlines()]
        cell = np.atleast_2d(np.genfromtxt(txt, dtype="U1"))
        Nneq = len(set(cell.flat))
        if len(tensors) != Nneq:
            raise ValueError("Tensor number do not match tiling")
        if axes_list is not None:
            if len(axes_list) != Nneq:
                raise ValueError("axes_list length does not match tiling")

        # store tensors according to cell.flat order
        neq_As = []
        for i, A0 in enumerate(tensors):
            if A0.ndim != 6:
                raise ValueError("Elementary tensor must be of rank 6")
            if axes_list is None:
                A = AsymmetricTensor.from_array(A0, 2)
            else:
                A = U1_SymmetricTensor.from_array(A0, axes_list[i], 2)
            neq_As.append(A)

        return cls(cell, neq_As)

    def get_data_to_save(self):
        """
        Return environment data as a dict to save in external file.
        """
        # do not store lists to avoid pickle
        # come back to elementary numpy arrays
        data = {"_CTM_cell": self._cell, "_CTM_symmetry": self._symmetry}

        if self._symmetry == "{e}":

            def save_data(rad, st):
                data[rad] = st.toarray()

        elif self._symmetry == "U(1)":
            # each axis U(1) representation is saved twice, not fully memory efficient
            # but much simpler.
            def save_data(rad, st):
                data[rad + "_block_irreps"] = st.block_irreps
                for j in range(st.nblocks):
                    data[rad + f"_block_{j}"] = st.blocks[j]
                for k in range(st.ndim):
                    data[rad + f"_axis_reps_{k}"] = st.axis_reps[k]

        for i in range(self._Nneq):
            save_data(f"_CTM_A_{i}", self._neq_As[i])
            save_data(f"_CTM_C1_{i}", self._neq_C1[i])
            save_data(f"_CTM_C2_{i}", self._neq_C2[i])
            save_data(f"_CTM_C3_{i}", self._neq_C3[i])
            save_data(f"_CTM_C4_{i}", self._neq_C4[i])
            save_data(f"_CTM_T1_{i}", self._neq_T1[i])
            save_data(f"_CTM_T2_{i}", self._neq_T2[i])
            save_data(f"_CTM_T3_{i}", self._neq_T3[i])
            save_data(f"_CTM_T4_{i}", self._neq_T4[i])
        return data

    @classmethod
    def from_file(cls, filename):
        """
        Construct CTM_Environment from save file.
        """
        with np.load(filename) as data:
            cell = data["_CTM_cell"]
            symmetry = str(data["_CTM_symmetry"])
            Nneq = len(set(cell.flat))

            neq_As = []
            neq_C1s = []
            neq_T1s = []
            neq_C2s = []
            neq_T2s = []
            neq_C3s = []
            neq_T3s = []
            neq_C4s = []
            neq_T4s = []

            if symmetry == "{e}":

                def load_data(rad, nleg_rows, ndim):
                    return AsymmetricTensor.from_array(data[rad], nleg_rows)

            elif symmetry == "U(1)":

                def load_data(rad, nleg_rows, ndim):
                    axes = tuple(data[rad + f"_axis_reps_{k}"] for k in range(ndim))
                    block_irreps = data[rad + "_block_irreps"]
                    blocks = tuple(
                        data[rad + "_block_{j}"] for j in range(block_irreps.size)
                    )
                    return U1_SymmetricTensor(axes, nleg_rows, blocks, block_irreps)

            for i in range(Nneq):
                neq_As.append(load_data(f"_CTM_A_{i}", 2, 6))
                neq_C1s.append(load_data(f"_CTM_C1_{i}", 1, 2))
                neq_C2s.append(load_data(f"_CTM_C2_{i}", 1, 2))
                neq_C3s.append(load_data(f"_CTM_C3_{i}", 1, 2))
                neq_C4s.append(load_data(f"_CTM_C4_{i}", 1, 2))
                neq_T1s.append(load_data(f"_CTM_T1_{i}", 3, 4))
                neq_T2s.append(load_data(f"_CTM_T2_{i}", 1, 4))
                neq_T3s.append(load_data(f"_CTM_T3_{i}", 3, 4))
                neq_T4s.append(load_data(f"_CTM_T4_{i}", 3, 4))

        env_tensors = {
            "neq_C1s": neq_C1s,
            "neq_T1s": neq_T1s,
            "neq_C2s": neq_C2s,
            "neq_T2s": neq_T2s,
            "neq_C3s": neq_C3s,
            "neq_T3s": neq_T3s,
            "neq_C4s": neq_C4s,
            "neq_T4s": neq_T4s,
        }

        return cls(cell, neq_As, env_tensors)

    def set_tensors(self, tensors, axes_list=None):
        assert axes_list is not None or self._symmetry == "{e}"
        if self._Nneq != len(tensors):
            raise ValueError("Incompatible cell and tensors")
        if axes_list is not None:
            if self._Nneq != len(axes_list):
                raise ValueError("Incompatible cell and axes")

        # we want to continue using the same environment tensors as the tensor are
        # updated (assuming tensors are still close). However, when the representation
        # on a given axis changes, this becomes very complicate (still possible using
        # "adapters"). Better to just restart environment in such casis.
        # nb: for abelian representations, irrep sorting does not matter, e.g. [0,1,0]
        # and [0,0,1] stay compatible.
        neq_As = []
        restart = False
        for i, A in enumerate(tensors):
            oldA = self._neq_As[i]
            if A.ndim != 6:
                raise ValueError("Elementary tensor must be of rank 6")
            if axes_list is None:
                newA = AsymmetricTensor.from_array(A, 2)
                if newA.shape != oldA.shape:
                    restart = True
            else:
                newA = U1_SymmetricTensor.from_array(A, axes_list[i], 2)
                if not (newA.axis_reps[0] == oldA.axis_reps[0]).all():
                    raise ValueError("Physical leg representation cannot change")
                if not (newA.axis_reps[1] == oldA.axis_reps[1]).all():
                    raise ValueError("Ancilla leg representation cannot change")
                if newA.shape != oldA.shape or not all(
                    (np.sort(newA.axis_reps[j]) == np.sort(oldA.axis_reps[j])).all()
                    for j in range(2, 7)
                ):
                    restart = True
            neq_As.append(newA)

        self._neq_As = neq_As
        if restart:
            print("WARNING: former environment is not compatible with updated tensors")
            print("restart environment from elementary tensors")
            self._Dmax = max(max(A.shape[2:]) for A in self._neq_As)
            self.restart()
        else:
            # reset all corners C-T // T-A since A changed
            self._corners_ul = [None] * self._Nneq
            self._corners_ur = [None] * self._Nneq
            self._corners_dl = [None] * self._Nneq
            self._corners_dr = [None] * self._Nneq

    @property
    def cell(self):
        return self._cell

    @property
    def Nneq(self):
        return self._Nneq

    @property
    def Lx(self):
        return self._Lx

    @property
    def Ly(self):
        return self._Ly

    @property
    def neq_coords(self):
        return self._neq_coords

    def get_tensor_type(self, x, y):
        return self._cell[x % self._Lx, y % self._Ly]

    def get_A(self, x, y):
        return self._neq_As[self._indices[x % self._Lx, y % self._Ly]]

    def get_C1(self, x, y):
        return self._neq_C1s[self._indices[x % self._Lx, y % self._Ly]]

    def get_T1(self, x, y):
        return self._neq_T1s[self._indices[x % self._Lx, y % self._Ly]]

    def get_C2(self, x, y):
        return self._neq_C2s[self._indices[x % self._Lx, y % self._Ly]]

    def get_T2(self, x, y):
        return self._neq_T2s[self._indices[x % self._Lx, y % self._Ly]]

    def get_C3(self, x, y):
        return self._neq_C3s[self._indices[x % self._Lx, y % self._Ly]]

    def get_T3(self, x, y):
        return self._neq_T3s[self._indices[x % self._Lx, y % self._Ly]]

    def get_C4(self, x, y):
        return self._neq_C4s[self._indices[x % self._Lx, y % self._Ly]]

    def get_T4(self, x, y):
        return self._neq_T4s[self._indices[x % self._Lx, y % self._Ly]]

    def get_P(self, x, y):
        return self._neq_P[self._indices[x % self._Lx, y % self._Ly]]

    def get_Pt(self, x, y):
        return self._neq_Pt[self._indices[x % self._Lx, y % self._Ly]]

    def get_a_ul(self, x, y):
        return self._a_ul[self._indices[x % self._Lx, y % self._Ly]]

    def get_a_ur(self, x, y):
        return self._a_ur[self._indices[x % self._Lx, y % self._Ly]]

    def get_a_rd(self, x, y):
        return self._a_rd[self._indices[x % self._Lx, y % self._Ly]]

    def get_a_dl(self, x, y):
        return self._a_dl[self._indices[x % self._Lx, y % self._Ly]]

    def get_corner_ul(self, x, y):
        return self._corners_ul[self._indices[x % self._Lx, y % self._Ly]]

    def get_corner_ur(self, x, y):
        return self._corners_ur[self._indices[x % self._Lx, y % self._Ly]]

    def get_corner_dl(self, x, y):
        return self._corners_dl[self._indices[x % self._Lx, y % self._Ly]]

    def get_corner_dr(self, x, y):
        return self._corners_dr[self._indices[x % self._Lx, y % self._Ly]]

    def set_corner_ul(self, x, y, ul):
        self._corners_ul[self._indices[x % self._Lx, y % self._Ly]] = ul

    def set_corner_ur(self, x, y, ur):
        self._corners_ur[self._indices[x % self._Lx, y % self._Ly]] = ur

    def set_corner_dl(self, x, y, dl):
        self._corners_dl[self._indices[x % self._Lx, y % self._Ly]] = dl

    def set_corner_dr(self, x, y, dr):
        self._corners_dr[self._indices[x % self._Lx, y % self._Ly]] = dr

    def store_projectors(self, x, y, P, Pt):
        j = self._indices[x % self._Lx, y % self._Ly]
        self._neq_P[j] = P
        self._neq_Pt[j] = Pt

    def store_renormalized_tensors(self, x, y, nCX, nT, nCY):
        j = self._indices[x % self._Lx, y % self._Ly]
        self._nCX[j] = nCX
        self._nT[j] = nT
        self._nCY[j] = nCY

    def _reset_temp_lists(self):
        # reset is needed because no list copy occurs
        self._neq_P = [None] * self._Nneq
        self._neq_Pt = [None] * self._Nneq
        self._nCX = [None] * self._Nneq
        self._nT = [None] * self._Nneq
        self._nCY = [None] * self._Nneq

    def fix_renormalized_up(self):
        self._neq_C1s = self._nCX
        self._neq_T1s = self._nT
        self._neq_C2s = self._nCY
        self._corners_ul = [None] * self._Nneq
        self._corners_ur = [None] * self._Nneq
        self._reset_temp_lists()

    def fix_renormalized_right(self):
        self._neq_C2s = self._nCX
        self._neq_T2s = self._nT
        self._neq_C3s = self._nCY
        self._corners_ur = [None] * self._Nneq
        self._corners_dr = [None] * self._Nneq
        self._reset_temp_lists()

    def fix_renormalized_down(self):
        self._neq_C3s = self._nCX
        self._neq_T3s = self._nT
        self._neq_C4s = self._nCY
        self._corners_dr = [None] * self._Nneq
        self._corners_dl = [None] * self._Nneq
        self._reset_temp_lists()

    def fix_renormalized_left(self):
        self._neq_C4s = self._nCX
        self._neq_T4s = self._nT
        self._neq_C1s = self._nCY
        self._corners_dl = [None] * self._Nneq
        self._corners_ul = [None] * self._Nneq
        self._reset_temp_lists()
